//--------------------------------------------------------------------------
// <summary>
//   
// </summary>
// <copyright file="ConsoleEx.cs" company="Chuck Hill">
// Copyright (c) 2020 Chuck Hill.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// The GNU Lesser General Public License can be viewed at
// http://www.opensource.org/licenses/lgpl-license.php. If
// you unfamiliar with this license or have questions about
// it, here is an http://www.gnu.org/licenses/gpl-faq.html.
//
// All code and executables are provided "as is" with no warranty
// either express or implied. The author accepts no liability for
// any damage or loss of business that this product may cause.
// </copyright>
// <repository>https://github.com/ChuckHill2/ChuckHill2.Utilities</repository>
// <author>Chuck Hill</author>
//--------------------------------------------------------------------------
using System;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using ChuckHill2.Extensions;
using ChuckHill2.Logging;

namespace ChuckHill2
{
    /// <summary>
    /// Additional System.Console-like API.
    /// </summary>
    public static class ConsoleEx  //there can only be one instance of the console
    {
        private static StreamWriter ConLog = null;
        private static TextWriter oldConOut = null;

        #region --- Win32 ---
        [DllImport("kernel32.dll")] private static extern bool AllocConsole();
        [DllImport("kernel32.dll")] private static extern bool AttachConsole(int pid);
        [DllImport("kernel32.dll")] private static extern bool FreeConsole();

        private enum STD_HANDLE { INPUT = -10, OUTPUT = -11, ERROR = -12 };
        [DllImport("Kernel32.dll")] private static extern IntPtr GetStdHandle(STD_HANDLE handleType);
        const int LF_FACESIZE = 32;
        [DllImport("Kernel32.dll")] private static extern IntPtr GetConsoleWindow();
        [DllImport("Kernel32.dll")] private static extern bool GetConsoleMode(IntPtr hConsoleOutput, out ConsoleOutputMode mode);
        [DllImport("Kernel32.dll")] private static extern bool SetConsoleMode(IntPtr hConsoleOutput, ConsoleOutputMode mode);
        [DllImport("Kernel32.dll")] private static extern bool GetConsoleMode(IntPtr hConsoleInput, out ConsoleInputMode mode);
        [DllImport("Kernel32.dll")] private static extern bool SetConsoleMode(IntPtr hConsoleInput, ConsoleInputMode mode);
        [Flags] private enum ConsoleInputMode
        {
            DISABLE_ALL = 0,
            ENABLE_PROCESSED_INPUT = 0x0001, //CTRL+C is processed by the system and is not placed in the input buffer. If the input buffer is being read by ReadFile or ReadConsole, other control keys are processed by the system and are not returned in the ReadFile or ReadConsole buffer. If the ENABLE_LINE_INPUT mode is also enabled, backspace, carriage return, and line feed characters are handled by the system.
            ENABLE_LINE_INPUT = 0x0002, //The ReadFile or ReadConsole function returns only when a carriage return character is read. If this mode is disabled, the functions return when one or more characters are available.
            ENABLE_ECHO_INPUT = 0x0004, //Characters read by the ReadFile or ReadConsole function are written to the active screen buffer as they are read. This mode can be used only if the ENABLE_LINE_INPUT mode is also enabled.
            ENABLE_WINDOW_INPUT = 0x0008, //User interactions that change the size of the console screen buffer are reported in the console's input buffer. Information about these events can be read from the input buffer by applications using the ReadConsoleInput function, but not by those using ReadFile or ReadConsole.
            ENABLE_MOUSE_INPUT = 0x0010, //If the mouse pointer is within the borders of the console window and the window has the keyboard focus, mouse events generated by mouse movement and button presses are placed in the input buffer. These events are discarded by ReadFile or ReadConsole, even when this mode is enabled.
            ENABLE_INSERT_MODE = 0x0020, //When enabled, text entered in a console window will be inserted at the current cursor location and all text following that location will not be overwritten. When disabled, all following text will be overwritten. To enable this mode, use ENABLE_INSERT_MODE | ENABLE_EXTENDED_FLAGS. To disable this mode, use ENABLE_EXTENDED_FLAGS without this flag.
            ENABLE_QUICK_EDIT_MODE = 0x0040, //This flag enables the user to use the mouse to select and edit text. To enable this mode, use ENABLE_QUICK_EDIT_MODE | ENABLE_EXTENDED_FLAGS. To disable this mode, use ENABLE_EXTENDED_FLAGS without this flag.
            ENABLE_EXTENDED_FLAGS = 0x0080, //Required to enable or disable extended flags. See ENABLE_INSERT_MODE and ENABLE_QUICK_EDIT_MODE.
            ENABLE_AUTO_POSITION = 0x0100, //When enabled, the operating system determines the location of your console windows when they are opened. This value cannot be be set.
        }
        [Flags] private enum ConsoleOutputMode
        {
            DISABLE_ALL = 0,
            ENABLE_PROCESSED_OUTPUT = 0x0001, //Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are parsed for ASCII control sequences, and the correct action is performed. Backspace, tab, bell, carriage return, and line feed characters are processed.
            ENABLE_WRAP_AT_EOL_OUTPUT = 0x0002, //When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row. This causes the rows displayed in the console window to scroll up automatically when the cursor advances beyond the last row in the window. It also causes the contents of the console screen buffer to scroll up (discarding the top row of the console screen buffer) when the cursor advances beyond the last row in the console screen buffer. If this mode is disabled, the last character in the row is overwritten with any subsequent characters.
        }
        [DllImport("Kernel32.dll")] private static extern bool GetCurrentConsoleFontEx(IntPtr hConsoleOutput, bool bMaximumWindow, ref CONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
        [DllImport("Kernel32.dll")] private static extern bool SetCurrentConsoleFontEx(IntPtr hConsoleOutput, bool bMaximumWindow, ref CONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct CONSOLE_FONT_INFOEX
        {
            public Int32 cbSize;      //= 84 = 20+32*2 = Marshal.SizeOf(typeof(CONSOLE_FONT_INFOEX));
            public Int32 nFont;       //= 5;
            public Int16 FontSize_X;  //= 6;
            public Int16 FontSize_Y;  //= 9;
            public Int32 FontFamily;  //= 32;
            public Int32 FontWeight;  //=700;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = LF_FACESIZE)]
            public string lfFaceName; //="Terminal";
        }
        [DllImport("Kernel32.dll")] private static extern bool GetConsoleScreenBufferInfoEx(IntPtr hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFOEX csbe);
        [DllImport("Kernel32.dll")] private static extern bool SetConsoleScreenBufferInfoEx(IntPtr hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFOEX csbe);
        [StructLayout(LayoutKind.Sequential)]
        private struct CONSOLE_SCREEN_BUFFER_INFOEX
        {
            public Int32 cbSize;
            public Int16 Size_X;
            public Int16 Size_Y;
            public Int16 CursorPosition_X;
            public Int16 CursorPosition_Y;
            public Int16 wAttributes;
            public short Window_Left;
            public short Window_Top;
            public short Window_Right;
            public short Window_Bottom;
            public Int16 MaximumWindowSize_X;
            public Int16 MaximumWindowSize_Y;
            public Int16 wPopupAttributes;
            public bool bFullscreenSupported;
            public COLORREF Black;
            public COLORREF DarkBlue;
            public COLORREF DarkGreen;
            public COLORREF DarkCyan;
            public COLORREF DarkRed;
            public COLORREF DarkMagenta;
            public COLORREF DarkYellow;
            public COLORREF Gray;
            public COLORREF DarkGray;
            public COLORREF Blue;
            public COLORREF Green;
            public COLORREF Cyan;
            public COLORREF Red;
            public COLORREF Magenta;
            public COLORREF Yellow;
            public COLORREF White;
        }
        [StructLayout(LayoutKind.Sequential)]
        private struct COLORREF
        {
            private UInt32 ColorDWORD;
            public byte R { get { return (byte)(ColorDWORD >> 0 & 0x000000FF); } set { ColorDWORD &= (UInt32)value << 0 & 0x000000FF; } }
            public byte G { get { return (byte)(ColorDWORD >> 8 & 0x000000FF); } set { ColorDWORD &= (UInt32)value << 8 & 0x0000FF00; } }
            public byte B { get { return (byte)(ColorDWORD >> 16 & 0x000000FF); } set { ColorDWORD &= (UInt32)value << 16 & 0x00FF0000; } }
            public byte A { get { return (byte)(ColorDWORD >> 24 & 0x000000FF); } set { ColorDWORD &= (UInt32)value << 24 & 0xFF000000; } }
            public override string ToString() { return ((Color)this).ToString(); }
            public static bool operator !=(COLORREF left, COLORREF right) { return left.ColorDWORD != right.ColorDWORD; }
            public static bool operator ==(COLORREF left, COLORREF right) { return left.ColorDWORD == right.ColorDWORD; }
            public override bool Equals(object obj) { return ColorDWORD == (obj is Color ? ToArgb((Color)obj) : ((COLORREF)obj).ColorDWORD); }
            public override int GetHashCode() { return ((Color)this).GetHashCode(); }
            public static implicit operator Color(COLORREF v) { return Color.FromArgb(ToArgb(v)); }
            public static implicit operator COLORREF(Color v) { return new COLORREF() { ColorDWORD = ToArgb(v) }; }
            private static UInt32 ToArgb(Color v) { return unchecked((UInt32)v.ToArgb()); }
            private static Int32 ToArgb(COLORREF v) { return unchecked((Int32)v.ColorDWORD); }
        }
        #endregion

        /// <summary>
        /// Create and attach console window to this process if it does not already exist.
        /// </summary>
        /// <returns>true if created else false if already exists.</returns>
        public static bool Create()
        {
            if (ConsoleEx.Exists()) return false;
            if (!AttachConsole(-1)) // Attach to an parent process console
            {
                oldConOut = Console.Out; //save to reset upon close
                AllocConsole(); // Alloc a new console
                var safeFileHandle = new Microsoft.Win32.SafeHandles.SafeFileHandle(GetStdHandle(STD_HANDLE.OUTPUT), true);
                var fileStream = new FileStream(safeFileHandle, FileAccess.Write);
                var stdOut = new StreamWriter(fileStream, Console.Out.Encoding);
                stdOut.AutoFlush = true;
                Console.SetOut(TextWriter.Synchronized(stdOut));
                return true;
            }
            return false;
        }

        /// <summary>
        /// Determine if a console window is attached to this process.
        /// </summary>
        /// <remarks>
        /// If a Win32 console handle is -1 (e.g. INVALIDHANDLE) or 0 if the process 
        /// does not have any associated standard handles such as a service that does
        /// not have its console I/O handles redirected.
        /// </remarks>
        public static bool Exists() { return (GetStdHandle(STD_HANDLE.INPUT).ToInt32() > 0); }

        /// <summary>
        /// Sets console window attributes more conducive to an output status window.
        /// </summary>
        /// <param name="title">Console window title</param>
        /// <param name="backgroundColor">Color of window background</param>
        /// <param name="textColor">Color of console text</param>
        /// <returns>false if there is NO associated console window</returns>
        /// <remarks>
        /// This consists of not only setting the caller-specified title and window colors, but also 
        /// (1)setting the font to a smaller size (still very readable).
        /// (2)Enabling select text and copy to clipboard.
        /// (3)Setting the buffer to a very large size (256x9999) to support a lot of scrolling status text.
        /// (4)Setting the window size to a slightly larger size (reasonable with the smaller font) to make
        ///    the scrolling status text visible longer before it scrolls off the window.
        /// </remarks>
        public static bool SetStdStatusProperties(string title, Color backgroundColor, Color textColor)
        {
            IntPtr hConsoleOutput = GetStdHandle(STD_HANDLE.OUTPUT);
            IntPtr hConsoleInput = GetStdHandle(STD_HANDLE.INPUT);
            if (hConsoleInput.ToInt32() <= 0) return false;  //No console window!
            bool ok = false;

            //----------------------
            //Get Console Attributes
            //----------------------

            ConsoleInputMode conInMode;
            ok = GetConsoleMode(hConsoleInput, out conInMode);

            //We don't need to set anything because users are not writing to the console window
            //ConsoleOutputMode conOutMode;
            //ok = GetConsoleMode(hOutput, out conOutMode);

            CONSOLE_FONT_INFOEX cfi = new CONSOLE_FONT_INFOEX();
            cfi.cbSize = Marshal.SizeOf(typeof(CONSOLE_FONT_INFOEX));
            ok = GetCurrentConsoleFontEx(hConsoleOutput, false, ref cfi);

            CONSOLE_SCREEN_BUFFER_INFOEX csb = new CONSOLE_SCREEN_BUFFER_INFOEX();
            csb.cbSize = Marshal.SizeOf(typeof(CONSOLE_SCREEN_BUFFER_INFOEX));
            ok = GetConsoleScreenBufferInfoEx(hConsoleOutput, ref csb);

            //---------------------------------------------
            //Tweak the console attributes and update them.
            //---------------------------------------------

            //Add ability to click and select text to copy to the clipboard.
            conInMode |= ConsoleInputMode.ENABLE_QUICK_EDIT_MODE | ConsoleInputMode.ENABLE_EXTENDED_FLAGS;
            ok = SetConsoleMode(hConsoleInput, conInMode);

            //Use small but very readable font to optimize desktop real estate.
            cfi.FontSize_X = 6;
            cfi.FontSize_Y = 8;
            ok = SetCurrentConsoleFontEx(hConsoleOutput, false, ref cfi);

            //Set console text and background colors.
            csb.Gray = textColor;
            csb.Black = backgroundColor;
            ok = SetConsoleScreenBufferInfoEx(hConsoleOutput, ref csb);

            //There are only 16 color values (e.g. Console only supports 4-bit color).
            //We set the color indices to match the colors we had set above.
            System.Console.BackgroundColor = ConsoleColor.Black;
            System.Console.ForegroundColor = ConsoleColor.Gray;
            System.Console.Title = title;
            System.Console.BufferWidth = 256;  //Make console buffer huge to hold a lot of text before rolling over.
            System.Console.BufferHeight = 9999;
            System.Console.WindowWidth = 80;  //Nice console window size. User will have to manually 
            System.Console.WindowHeight = 50; //resize or scroll to see additional status text.
            System.Console.Clear();  //clears the text buffer but also sets the foreground/background colors.

            return true;
        }

        /// <summary>
        /// Stop logging and close console if created here.
        /// </summary>
        public static void Close()
        {
            if (ConLog != null) { ConLog.Dispose(); ConLog = null; }
            if (oldConOut != null) //We created the console, so we cleanup
            { 
                FreeConsole();
                TextWriter currentOut = Console.Out;
                Console.SetOut(oldConOut);
                currentOut.Dispose();
                oldConOut = null;
            }
        }

        /// <summary>
        /// Split console output stream to a file. Only captures output written to console from within 
        /// C# environment (e.g. Console.Writeline()). Output written via Win32 API are NOT captured!
        /// Writes are NOT blocking and are written lazily.
        /// </summary>
        /// <param name="filename">
        /// Filename to copy console output to. If null or empty, the existing output to file is closed.
        /// Output continues ONLY to the console. May throw an exception if unable to open the file.
        /// </param>
        public static void CopyToFile(string filename)
        {
            if (filename.IsNullOrEmpty() && ConLog != null)
            {
                ConLog.Dispose();
                ConLog = null;
                return;
            }
            if (filename.IsNullOrEmpty()) return;
            ConLog = new ConsoleLogger(OpenFile(filename), Encoding.UTF8);
            Console.WriteLine();
        }

        /// <summary>
        /// Robust open a new or existing file for write. If an existing file is too large (100MB), 
        /// it is renamed and moved to the side (same name but includes the file creation date).
        /// If the filename cannot be opened for any reason (permissions?), the filename will
        /// be modified to point to %LocalAppData\exename\ instead.
        /// </summary>
        /// <param name="filename"></param>
        /// <returns>opened file stream or null upon error</returns>
        private static FileStream OpenFile(string filename)
        {
            FileStream fs = null;
            while (true)
            {
                if (File.Exists(filename) && new FileInfo(filename).Length > (100 * 1048576)) //move over if over 100MB
                {
                    try
                    {
                        string s = Path.GetDirectoryName(filename) + Path.GetFileNameWithoutExtension(filename) + "." + File.GetCreationTime(filename).ToString("yyyyMMddHHmmss") + Path.GetExtension(filename);
                        File.Move(filename, s);
                    }
                    catch { }
                }
                try { fs = File.Open(filename, FileMode.Append, FileAccess.Write, FileShare.ReadWrite); }
                catch { }
                if (fs == null)
                {
                    var subdir = "\\" + Path.GetFileNameWithoutExtension(Process.GetCurrentProcess().MainModule.FileName.Replace(".vshost", ""));
                    string s = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + subdir;
                    if (!Directory.Exists(s)) Directory.CreateDirectory(s);
                    filename = Path.GetFullPath(Path.Combine(s, Path.GetFileName(filename)));
                    continue;
                }
                break;
            }
            return fs;
        }

        /// <summary>
        /// Determine if we are copying console output to a file
        /// </summary>
        public static bool IsLogging { get { return (ConLog!=null); } }

        #region public class RawConsole
        /// <summary>
        /// Handy low-level utility for writing directly to console, bypassing all C++/.NET interfaces.
        /// Contains only one function - Write()
        /// </summary>
        public class RawConsole : IDisposable
        {
            [DllImport("kernel32.dll", CharSet = CharSet.Ansi)] private static extern bool WriteFile(IntPtr hFile, String lpBuffer, Int32 nNumberOfBytesToWrite, out Int32 lpNumberOfBytesWritten, IntPtr Overlapped);
            [DllImport("Kernel32.dll")] private static extern bool CloseHandle(IntPtr hFile);
            [DllImport("Kernel32.dll", CharSet = CharSet.Unicode)] private static extern IntPtr CreateFile(String name, Int32 DesiredAccess, Int32 ShareMode, IntPtr SecurityAttributes, Int32 CreationDisposition, Int32 FlagsAndAttributes, IntPtr hTemplateFile);
            private readonly IntPtr INVALID_HANDLE = new IntPtr(-1);
            private const int OPEN_EXISTING = 3;
            private const int GENERIC_WRITE = 0x40000000;
            private const int FILE_SHARE_WRITE = 0x00000002;
            private IntPtr hFile;

            /// <summary>
            /// Initialize for writing directly to console
            /// </summary>
            public RawConsole()
            {
                hFile = CreateFile("CON", GENERIC_WRITE, FILE_SHARE_WRITE, IntPtr.Zero, OPEN_EXISTING, 0, IntPtr.Zero);
                if (hFile == IntPtr.Zero || hFile == INVALID_HANDLE) hFile = IntPtr.Zero;
            }
            /// <summary>
            /// Write string directly to raw console output. Bypasses C++ StdLib and C#. 
            /// If console does not exist or handle is already closed, this method does nothing.
            /// </summary>
            /// <param name="s">String to write. Does NOT append a newline.</param>
            public void Write(string s)
            {
                int nbytes;
                if (hFile == IntPtr.Zero) return;
                WriteFile(hFile, s, s.Length, out nbytes, IntPtr.Zero);
            }

            /// <summary>
            /// Dispose/close open console handle. Does nothing if already closed.
            /// </summary>
            public void Dispose()
            {
                if (hFile == IntPtr.Zero) return;
                CloseHandle(hFile);
            }
        }
        #endregion

        #region private class ConsoleLogger : System.IO.StreamWriter
        private class ConsoleLogger : System.IO.StreamWriter
        {
            private TextWriter oldOut;
            private bool writeConOut = true;
            private IWriterBase<string> writer; //queue message strings so the caller can return immediately.
            Mutex mutex = null; //force exclusive write on a shared file. Useful when writing from multiple AppDomains.

            public ConsoleLogger(Stream stream) : base(stream) { ConsoleLoggerInit(); }
            public ConsoleLogger(string path) : base(path) { ConsoleLoggerInit(); }
            public ConsoleLogger(Stream stream, Encoding encoding) : base(stream, encoding) { ConsoleLoggerInit(); }
            public ConsoleLogger(string path, bool append) : base(path, append) { ConsoleLoggerInit(); }
            public ConsoleLogger(Stream stream, Encoding encoding, int bufferSize) : base(stream, encoding, bufferSize) { ConsoleLoggerInit(); }
            public ConsoleLogger(string path, bool append, Encoding encoding) : base(path, append, encoding) { ConsoleLoggerInit(); }
            public ConsoleLogger(string path, bool append, Encoding encoding, int bufferSize) : base(path, append, encoding, bufferSize) { ConsoleLoggerInit(); }

            private void ConsoleLoggerInit()
            {
                if (base.BaseStream is FileStream)
                {
                    string id = ((FileStream)base.BaseStream).Name.ToIdentifier();
                    bool createdNew;
                    mutex = new Mutex(false, id, out createdNew);
                }
                writer = new QWriter(this);  //Asynchronous
                //writer = new SyncWriter(this); //Synchronous
                oldOut = System.Console.Out;
                System.Console.SetOut(this);
                writeConOut = true;
            }

            public override void Close()
            {
                writeConOut = false;
                System.Console.SetOut(oldOut);
                oldOut = null;
                if (writer != null) { writer.Close(); writer = null; }
                if (mutex != null) { mutex.Close(); mutex = null; }
            }
            protected override void Dispose(bool disposing)
            {
                this.Close();
                base.Dispose(disposing);
            }

            #region public void Write(value) [overloaded]
            public override void Write(bool value) { writer.Write(value.ToString()); }
            public override void Write(char value) { writer.Write(value.ToString()); }
            public override void Write(char[] buffer) { writer.Write(new String(buffer)); }
            public override void Write(char[] buffer, int index, int count) { writer.Write(new String(buffer, index, count)); }
            public override void Write(decimal value) { writer.Write(value.ToString()); }
            public override void Write(double value) { writer.Write(value.ToString()); }
            public override void Write(float value) { writer.Write(value.ToString()); }
            public override void Write(int value) { writer.Write(value.ToString()); }
            public override void Write(long value) { writer.Write(value.ToString()); }
            public override void Write(object value) { writer.Write(value.ToString()); }
            public override void Write(string format, object arg0) { writer.Write(string.Format(format, arg0)); }
            public override void Write(string format, object arg0, object arg1) { writer.Write(string.Format(format, arg0, arg1)); }
            public override void Write(string format, object arg0, object arg1, object arg2) { writer.Write(string.Format(format, arg0, arg1, arg2)); }
            public override void Write(string format, params object[] arg) { writer.Write(string.Format(format, arg)); }
            public override void Write(string value) { writer.Write(value); }
            public override void Write(uint value) { writer.Write(value.ToString()); }
            public override void Write(ulong value) { writer.Write(value.ToString()); }
            public override void WriteLine() { writer.Write(this.NewLine); }
            public override void WriteLine(bool value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(char value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(char[] buffer) { writer.Write(new String(buffer) + this.NewLine); }
            public override void WriteLine(char[] buffer, int index, int count) { writer.Write(new String(buffer, index, count) + this.NewLine); }
            public override void WriteLine(decimal value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(double value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(float value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(int value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(long value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(object value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(string format, object arg0) { writer.Write(string.Format(format, arg0) + this.NewLine); }
            public override void WriteLine(string format, object arg0, object arg1) { writer.Write(string.Format(format, arg0, arg1) + this.NewLine); }
            public override void WriteLine(string format, object arg0, object arg1, object arg2) { writer.Write(string.Format(format, arg0, arg1, arg2) + this.NewLine); }
            public override void WriteLine(string format, params object[] arg) { writer.Write(string.Format(format, arg) + this.NewLine); }
            public override void WriteLine(string value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(uint value) { writer.Write(value.ToString() + this.NewLine); }
            public override void WriteLine(ulong value) { writer.Write(value.ToString() + this.NewLine); }
            #endregion

            //used internally by IWriterBase<>
            private void WriteInternal(string s)
            {
                if (mutex != null) mutex.WaitOne(3000);
                if (writeConOut)
                {
                    try { oldOut.Write(s); }
                    catch { writeConOut = false; }
                }
                try
                {
                    if (base.BaseStream.CanSeek) base.BaseStream.Seek(0, SeekOrigin.End);
                    base.Write(s);
                    base.Flush();
                }
                catch { }
                if (mutex != null) mutex.ReleaseMutex();
            }

            #region private class QWriter : QWriterBase<string>
            /// <summary>
            /// Asynchronous write to an existing stream. 
            /// </summary>
            private class QWriter : QWriterBase<string>
            {
                ConsoleLogger m_logger;
                public QWriter(ConsoleLogger outStream) : base("Console", true, new object[]{outStream}) { }

                protected override void LoggerInit(object[] args)
                {
                    m_logger = args[0] as ConsoleLogger;
                    base.m_name = "Console";
                    //base.m_threadName = "Console " + base.m_threadName;
                }

                protected override void LoggerClose()
                {
                    if (m_logger != null) { m_logger = null; }
                }

                protected override void LoggerWrite(string msg)
                {
                    m_logger.WriteInternal(msg);
                }
            }
            #endregion

            #region private class SyncWriter : IWriterBase<string>
            /// <summary>
            /// Synchronous write to an existing stream. 
            /// </summary>
            private class SyncWriter : IWriterBase<string>
            {
                ConsoleLogger m_logger;

                public SyncWriter(ConsoleLogger outStream) { m_logger = outStream; }

                public string Name
                {
                    get { return "Console Writer"; }
                }

                public void Write(string msg)
                {
                    m_logger.WriteInternal(msg);
                }

                public void Close()
                {
                    if (m_logger != null) { m_logger = null; }
                }

                public bool IsClosed
                {
                    get
                    {
                        return m_logger == null;
                    }
                }
            }
            #endregion
        }
        #endregion

    }
}
