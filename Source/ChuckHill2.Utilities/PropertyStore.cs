//--------------------------------------------------------------------------
// <summary>
//   
// </summary>
// <copyright file="PropertyStore.cs" company="Chuck Hill">
// Copyright (c) 2020 Chuck Hill.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// The GNU Lesser General Public License can be viewed at
// http://www.opensource.org/licenses/lgpl-license.php. If
// you unfamiliar with this license or have questions about
// it, here is an http://www.gnu.org/licenses/gpl-faq.html.
//
// All code and executables are provided "as is" with no warranty
// either express or implied. The author accepts no liability for
// any damage or loss of business that this product may cause.
// </copyright>
// <repository>https://github.com/ChuckHill2/ChuckHill2.Utilities</repository>
// <author>Chuck Hill</author>
//--------------------------------------------------------------------------
using System;
using System.Reflection;
using System.Windows.Forms;

namespace ChuckHill2
{
    /// <summary>
    /// Controls have an internal generic property store for associating any objects. _Control.Tag_ is a builtin example that uses the generic property store. These methods expose the internal Control.PropertyStore for our own use.
    /// </summary>
    /// <remarks>
    /// Internally, this is implemented as a type of dictionary for efficiency.
    /// 
    /// There are two mechanisms for associating data with a window.
    /// 1. Associate data with .NET System.Windows.Control. See PropertyStore.SetObject(). Useful for sharing data with other .Net methods.
    /// 2. Associate data with the Win32 windows handle. See Win32.NativeMethods.SetWindowProperty<T>(). Useful for sharing data thru the win32 interface, such as .net WndProc() and other win32 API. Data is stored by value.
    /// </remarks>
    public class PropertyStore
    {
        //Note: the these methods are public but the class is marked as internal and variable Control.propertyStore is private, so we must use reflection.
        private static readonly FieldInfo fiPropertyStore = typeof(Control).GetField("propertyStore", BindingFlags.Instance | BindingFlags.NonPublic);

        private static readonly Type tPropertyStore = Type.GetType("System.Windows.Forms.PropertyStore, " + typeof(System.Windows.Forms.Control).Assembly.FullName, false, false);

        private static readonly MethodInfo miCreateKey = tPropertyStore.GetMethod("CreateKey", BindingFlags.Static | BindingFlags.Public);

        private static readonly MethodInfo miGetObject = tPropertyStore.GetMethod("GetObject", BindingFlags.Instance | BindingFlags.Public, null, new Type[] { typeof(int) }, null);
        private static readonly MethodInfo miSetObject = tPropertyStore.GetMethod("SetObject", BindingFlags.Instance | BindingFlags.Public, null, new Type[] { typeof(int), typeof(Object) }, null);

        private static readonly MethodInfo miGetInteger = tPropertyStore.GetMethod("GetInteger", BindingFlags.Instance | BindingFlags.Public, null, new Type[] { typeof(int) }, null);
        private static readonly MethodInfo miSetInteger = tPropertyStore.GetMethod("SetInteger", BindingFlags.Instance | BindingFlags.Public, null, new Type[] { typeof(int), typeof(int) }, null);


        /// <summary>
        ///    Generates a new unique property key used to reference associated property value of a control.
        /// </summary>
        /// <returns>Unique integer property key</returns>
        public static int CreateKey() { return (int)miCreateKey.Invoke(null, new object[] { }); }

        /// <summary>
        ///    Returns specified property from control. Returns null if not found.
        /// </summary>
        /// <param name="c">Control containing property.</param>
        /// <param name="key">Unique integer key (generated by CreateKey) to specified property</param>
        /// <returns>Property value or null if not found.</returns>
        public static object GetObject(Control c, int key) { return miGetObject.Invoke(fiPropertyStore.GetValue(c), new object[] { key }); }

        /// <summary>
        ///    Create or reassign property value to a specified control and key.
        /// </summary>
        /// <param name="c">Control to assign property.</param>
        /// <param name="key">Unique integer key (generated by CreateKey) to specified property</param>
        /// <param name="value">Value to associate with control and key.</param>
        public static void SetObject(Control c, int key, object value) { miSetObject.Invoke(fiPropertyStore.GetValue(c), new object[] { key, value }); }

        /// <summary>
        ///    Returns specified integer property from a control. Returns zero if not found.
        /// </summary>
        /// <remarks>
        /// Integer properties are a special case and are handled in a different storage space. Not entirely clear why since the implementation and result is identical to the object storage space. Legacy? Fewer casts?
        /// </remarks>
        /// <param name="c">Control containing property.</param>
        /// <param name="key">Unique integer key (generated by CreateKey) to specified property</param>
        /// <returns>Property value or zero if not found.</returns>
        public static int GetInteger(Control c, int key) { return (int)miGetInteger.Invoke(fiPropertyStore.GetValue(c), new object[] { key }); }

        /// <summary>
        ///    Create or reassign integer property value to a specified control and key.
        /// </summary>
        /// <remarks>
        /// Integer properties are a special case and are handled in a different storage space. Not entirely clear why since the implementation and result is identical to the object storage space. Legacy? Fewer casts?
        /// </remarks>
        /// <param name="c">Control to assign property.</param>
        /// <param name="key">Unique integer key (generated by CreateKey) to specified property</param>
        /// <param name="value">Integer value to associate with control and key.</param>
        public static void SetInteger(Control c, int key, int value) { miSetInteger.Invoke(fiPropertyStore.GetValue(c), new object[] { key, value }); }
    }
}
