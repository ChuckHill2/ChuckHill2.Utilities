<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChuckHill2.Utilities: ChuckHill2.Async Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="Doxygen_Extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ProjectLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChuckHill2.Utilities
   &#160;<span id="projectnumber">1.0.1.0</span>
   </div>
   <div id="projectbrief">C# WinForms Utility Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_chuck_hill2.html">ChuckHill2</a></li><li class="navelem"><a class="el" href="class_chuck_hill2_1_1_async.html">Async</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_chuck_hill2_1_1_async-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ChuckHill2.Async Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate. <br  />
 It is similar in functionality to Control.BeginInvoke()/EndInvoke() however this will never conflict or be queued with other commands since it runs on its own separate, independent, and private thread. It is also similar in functionality to ThreadPool.QueueUserWorkItem() but threadpool threads belong to MultiThreadedApartment(MTA). Any .NET API that uses OLE behind the scenes, including any using System.Interop, will cause an exception when executed within the ThreadPool!  
 <a href="class_chuck_hill2_1_1_async.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad467e6327cfd51f6407c7248b5601a3c"><td class="memItemLeft" align="right" valign="top">delegate bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#ad467e6327cfd51f6407c7248b5601a3c">Callback</a> (object[] userValues)</td></tr>
<tr class="memdesc:ad467e6327cfd51f6407c7248b5601a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a> callback delegate.  <a href="class_chuck_hill2_1_1_async.html#ad467e6327cfd51f6407c7248b5601a3c">More...</a><br /></td></tr>
<tr class="separator:ad467e6327cfd51f6407c7248b5601a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa37dbe8fcd70cc2ced17df9da4b744a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#aaa37dbe8fcd70cc2ced17df9da4b744a">Async</a> (string threadName, <a class="el" href="class_chuck_hill2_1_1_async.html#ad467e6327cfd51f6407c7248b5601a3c">Callback</a> func)</td></tr>
<tr class="memdesc:aaa37dbe8fcd70cc2ced17df9da4b744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy class for calling a function asynchronously, and repeatedly. Upon completion, <a class="el" href="class_chuck_hill2_1_1_async.html#a36f2778215c92116641ba7f7b6fc6e22" title="Stops thread and cleans up this Async object. Useful particularly within Form.Dispose()....">Exit()</a> must be called to close the thread. Example: <a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a> m_Async = new <a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a>("CopyToClipboard", new <a class="el" href="class_chuck_hill2_1_1_async.html#ad467e6327cfd51f6407c7248b5601a3c" title="Async callback delegate.">Async.Callback</a>(this.CopyToClipboard), null);  <a href="class_chuck_hill2_1_1_async.html#aaa37dbe8fcd70cc2ced17df9da4b744a">More...</a><br /></td></tr>
<tr class="separator:aaa37dbe8fcd70cc2ced17df9da4b744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde837ac8ad875b85113ab37d626ecc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#abde837ac8ad875b85113ab37d626ecc8">Kill</a> ()</td></tr>
<tr class="memdesc:abde837ac8ad875b85113ab37d626ecc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only necessary if the callback function is hung or extremly busy.  <a href="class_chuck_hill2_1_1_async.html#abde837ac8ad875b85113ab37d626ecc8">More...</a><br /></td></tr>
<tr class="separator:abde837ac8ad875b85113ab37d626ecc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88554e236cca5fecfb7863fa92dc2f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#aa88554e236cca5fecfb7863fa92dc2f7">Trigger</a> ()</td></tr>
<tr class="memdesc:aa88554e236cca5fecfb7863fa92dc2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the registered callback function asynchronously. This function returns immediately.  <a href="class_chuck_hill2_1_1_async.html#aa88554e236cca5fecfb7863fa92dc2f7">More...</a><br /></td></tr>
<tr class="separator:aa88554e236cca5fecfb7863fa92dc2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8c4191d85dab5c594961264b0e65e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#acf8c4191d85dab5c594961264b0e65e2">Trigger</a> (object[] objs)</td></tr>
<tr class="memdesc:acf8c4191d85dab5c594961264b0e65e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the registered callback function asynchronously. This function returns immediately.  <a href="class_chuck_hill2_1_1_async.html#acf8c4191d85dab5c594961264b0e65e2">More...</a><br /></td></tr>
<tr class="separator:acf8c4191d85dab5c594961264b0e65e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9850e86a2822f8aa434ffb5780971e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#a5a9850e86a2822f8aa434ffb5780971e">FlushQueue</a> ()</td></tr>
<tr class="memdesc:a5a9850e86a2822f8aa434ffb5780971e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all outstanding Trigger/jobs from queue.  <a href="class_chuck_hill2_1_1_async.html#a5a9850e86a2822f8aa434ffb5780971e">More...</a><br /></td></tr>
<tr class="separator:a5a9850e86a2822f8aa434ffb5780971e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4773877f1691734801b6eb9a302b350d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#a4773877f1691734801b6eb9a302b350d">QueueCount</a> ()</td></tr>
<tr class="memdesc:a4773877f1691734801b6eb9a302b350d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current number of items in queue.  <a href="class_chuck_hill2_1_1_async.html#a4773877f1691734801b6eb9a302b350d">More...</a><br /></td></tr>
<tr class="separator:a4773877f1691734801b6eb9a302b350d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f2778215c92116641ba7f7b6fc6e22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#a36f2778215c92116641ba7f7b6fc6e22">Exit</a> ()</td></tr>
<tr class="memdesc:a36f2778215c92116641ba7f7b6fc6e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops thread and cleans up this <a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a> object. Useful particularly within Form.Dispose(). Add the line: "if (m_Async!=null) m_Async.Exit();" This is only necessary if you want to cleanup before application exit to avoid resource leaks during runtime.  <a href="class_chuck_hill2_1_1_async.html#a36f2778215c92116641ba7f7b6fc6e22">More...</a><br /></td></tr>
<tr class="separator:a36f2778215c92116641ba7f7b6fc6e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f19a9a7b95efb712eaf68acf35a88d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chuck_hill2_1_1_async.html#aa7f19a9a7b95efb712eaf68acf35a88d">IsRunning</a> ()</td></tr>
<tr class="memdesc:aa7f19a9a7b95efb712eaf68acf35a88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if thread is still running.  <a href="class_chuck_hill2_1_1_async.html#aa7f19a9a7b95efb712eaf68acf35a88d">More...</a><br /></td></tr>
<tr class="separator:aa7f19a9a7b95efb712eaf68acf35a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate. <br  />
 It is similar in functionality to Control.BeginInvoke()/EndInvoke() however this will never conflict or be queued with other commands since it runs on its own separate, independent, and private thread. It is also similar in functionality to ThreadPool.QueueUserWorkItem() but threadpool threads belong to MultiThreadedApartment(MTA). Any .NET API that uses OLE behind the scenes, including any using System.Interop, will cause an exception when executed within the ThreadPool! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa37dbe8fcd70cc2ced17df9da4b744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa37dbe8fcd70cc2ced17df9da4b744a">&#9670;&nbsp;</a></span>Async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChuckHill2.Async.Async </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>threadName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chuck_hill2_1_1_async.html#ad467e6327cfd51f6407c7248b5601a3c">Callback</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handy class for calling a function asynchronously, and repeatedly. Upon completion, <a class="el" href="class_chuck_hill2_1_1_async.html#a36f2778215c92116641ba7f7b6fc6e22" title="Stops thread and cleans up this Async object. Useful particularly within Form.Dispose()....">Exit()</a> must be called to close the thread. Example: <a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a> m_Async = new <a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a>("CopyToClipboard", new <a class="el" href="class_chuck_hill2_1_1_async.html#ad467e6327cfd51f6407c7248b5601a3c" title="Async callback delegate.">Async.Callback</a>(this.CopyToClipboard), null); </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadName</td><td>Optional name for thread.</td></tr>
    <tr><td class="paramname">func</td><td>Callback function: bool Callback(Object userValue) <br  />
 Return true to continue waiting for next invocation trigger or false to exit thread and cleanup. Returning false is useful for one-shot asynchronous calls.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad467e6327cfd51f6407c7248b5601a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad467e6327cfd51f6407c7248b5601a3c">&#9670;&nbsp;</a></span>Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate bool ChuckHill2.Async.Callback </td>
          <td>(</td>
          <td class="paramtype">object[]&#160;</td>
          <td class="paramname"><em>userValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a> callback delegate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userValues</td><td>Value to pass to the callback/delegate function. May be null if not used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to continue waiting for the next invocation <a class="el" href="class_chuck_hill2_1_1_async.html#aa88554e236cca5fecfb7863fa92dc2f7" title="Execute the registered callback function asynchronously. This function returns immediately.">Trigger()</a> or false to terminate thread and cleanup. <a class="el" href="class_chuck_hill2_1_1_async.html#a36f2778215c92116641ba7f7b6fc6e22" title="Stops thread and cleans up this Async object. Useful particularly within Form.Dispose()....">Exit()</a> does not need to be called (although it doesn't hurt) when returning false.</dd></dl>

</div>
</div>
<a id="a36f2778215c92116641ba7f7b6fc6e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f2778215c92116641ba7f7b6fc6e22">&#9670;&nbsp;</a></span>Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChuckHill2.Async.Exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops thread and cleans up this <a class="el" href="class_chuck_hill2_1_1_async.html" title="Non-GUI asynchronous event executor. It does not require a System.Windows.Forms object to operate....">Async</a> object. Useful particularly within Form.Dispose(). Add the line: "if (m_Async!=null) m_Async.Exit();" This is only necessary if you want to cleanup before application exit to avoid resource leaks during runtime. </p>

</div>
</div>
<a id="a5a9850e86a2822f8aa434ffb5780971e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9850e86a2822f8aa434ffb5780971e">&#9670;&nbsp;</a></span>FlushQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChuckHill2.Async.FlushQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all outstanding Trigger/jobs from queue. </p>

</div>
</div>
<a id="aa7f19a9a7b95efb712eaf68acf35a88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f19a9a7b95efb712eaf68acf35a88d">&#9670;&nbsp;</a></span>IsRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChuckHill2.Async.IsRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if thread is still running. </p>
<dl class="section return"><dt>Returns</dt><dd>true if it still running.</dd></dl>

</div>
</div>
<a id="abde837ac8ad875b85113ab37d626ecc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde837ac8ad875b85113ab37d626ecc8">&#9670;&nbsp;</a></span>Kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChuckHill2.Async.Kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only necessary if the callback function is hung or extremly busy. </p>

</div>
</div>
<a id="a4773877f1691734801b6eb9a302b350d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4773877f1691734801b6eb9a302b350d">&#9670;&nbsp;</a></span>QueueCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ChuckHill2.Async.QueueCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current number of items in queue. </p>

</div>
</div>
<a id="aa88554e236cca5fecfb7863fa92dc2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88554e236cca5fecfb7863fa92dc2f7">&#9670;&nbsp;</a></span>Trigger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChuckHill2.Async.Trigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the registered callback function asynchronously. This function returns immediately. </p>

</div>
</div>
<a id="acf8c4191d85dab5c594961264b0e65e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8c4191d85dab5c594961264b0e65e2">&#9670;&nbsp;</a></span>Trigger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChuckHill2.Async.Trigger </td>
          <td>(</td>
          <td class="paramtype">object[]&#160;</td>
          <td class="paramname"><em>objs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the registered callback function asynchronously. This function returns immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objs</td><td>Args to pass to registered callback function</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Async.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
